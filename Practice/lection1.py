# Чтобы писать в отдельном блоке, который можно отдельно ранить можно писать # %% в начале строки

print('Hello world!') # выводит строку

x = 1  # переменные - ссылки на объекты
y = 1
print(id(x))  # одинаковые индексы x и y, потому что x = y = 1
print(id(y))

"""Виды строк"""  # глобальные комментарии можно заключать в три двойные кавычки

bird_one = u'duck'  # 1 - по дефолту в питоне строки вида unicode
print(bird_one)  # поэтому выведется только 'duck' без u

bird_two = b'duck'  # 2 - 'byte' - байты, раньше были дефолтными
print(bird_two)  # Показывает компьютерное представление строки

bird_three = r'duck'  # 3 - 'raw' - сырые строки. Применяются при экранировании.
print(bird_three)  # Экранирование - изменение поведения конкретного символа

"""Операции (методы) над строками"""

bird_four = 'quack-quack'
print(bird_four.upper())  # .upper() - делает все буквы заглавными
print(bird_four.capitalize())  # .capitalize() - делает заглавным первый символ в строке
print(bird_four.encode())  # .encode() - позволяет сменить юникод кодировку на байтовую

bird_five = b'QUACK-QUAK'
print(bird_five.lower())  # .lower() - делает все символы в строке строчными
print(bird_five.decode())  # .decode() - раскодирует строку в юникод

bird_six = 'quack quack quack'
print(bird_six.strip('q'))  # .strip() - удаляет выбранный символ из начала и конца строки, если он есть
print(bird_six.strip(' '))  # если символ не указан, то удаляет пробелы из начала и конца строки
#.rstrip() - удаляет пробелы только справа, .lstrip() - только слева

print(bird_six.replace(' ','_'))  # заменяет первый символ в строке на второй

print(bird_six.split())  # .split() - разделяет строку на слова по указанному разделителю в ()
print('_'.join(bird_six))  # объединяет объект в строку через разделитель

"""Форматирование строк -- подстановка в нее какого-либо значения"""
# Задача: написать код, который считает сумму денег на счету у клиента и потом выдает ему сообщение:
# На вашем счету столько-то долларов.


# 1) Старый метод: в конце строки, в которую хотим что-то вставить, пишем %s, 
# а перед строкой, которую хотим вставить, пишем %

message = 'На вашем счету %s долларов'
print(message % '123')

# 2) Недавний метод: на место, куда будем вставлять, пишем {}
# Перед тем, что будем вставлять, пишем .format

message = 'На вашем счету {} долларов'
print(message.format(123))

# 3) Новый метод: вставка имеющейся строки, указанием ее в {}, но перед строкой пишем f

usd_total = 123
message = f'На вашем счету {usd_total} долларов'
print(message)

# Можно использовать \N для юникодных символов, зная их имя
print('\N{Weary Cat Face}')
print('\N{Bug}')

"""ТИП ДАННЫХ BOOLEAN"""
# Имеет 2 значения True и False (как 1 и 0)
# проверка значений осуществляется через "is"

foo = True
print(foo is not False)
print(foo)

print(True - 1)  # как 1 - 1 результатом будет 0
print(True + False) 

# True - любое ненулевое значение, False - нулевое значение.

"""Операторы BOOLEAN"""
# and - и
# or - или
# not - не (логическое отрицание)

is_cosy = True
is_cheap = False
is_wifi = True

if not (is_cosy or is_wifi) and is_cheap:
    print('No way!')
else:
    print('Nice')

"""Тип переменных NONE - по сути отсутствие значений"""

print(None is None)  # Сравнение через is
print(None == None) # Или через == (результатом будет True или False)

bird_seven = 'duck'
print(bird_seven is not None) # True
bird_eight = 0
print(bird_eight is None) # False

"""Числа"""
# int - универсальные целые числа
# float - числа с плавающей точкой
# complex - комплексные числа

print(float(42))
print(42j == complex(0,42) == 0 + 42j) #True

"""Операции над числами"""

print(4 / 2) # деление, в результате получаем float
print(5 // 2) # целочисленное деление 
print(5 % 2) # остаток от деления
print(5 ** 2) # возведение в степень
print( abs(-5)) # модуль
print(pow(2,3)) # тоже возведение в степень, но работает медленнее

"""Кортеж (tuple) - неизменяемый массив () = tuple() - упорядоченный набор элементов"""

tup = (0, 1, 3)
# tup[0] = 42 - выдаст ошибку, поскольку нельзя изменить элеиенты в кортеже

# В кортеж можно добавлять элементы и делать срезы, но будет создан новый объект, а не изменен старый

print(len(tup)) # длина кортежа len = 3
tup += (42,'meow','woof') # добавили элементы функцией +=
print(len(tup)) # длина кортежа 6

"""Нулевые значения для каждого типа в питоне"""

# None = None
# int = 0
# float = 0
# string = '' (пустая строка)
# bool = False
# list = [] (пустой лист/список) - изменяемый тип
# dict = {} или dict()  (пустой словарь) - изменяемый тип
# set = set() (пустой сет/множество) - изменяемый тип

"""list - список, упорядоченный набор элементов, изменяемый
все элементы списка имеют индекс, нумерация начинается с нуля"""

x = list()
x = []
x = ['a','b','c']
print('a' in x) # оператор in проверяет вхождение элемента в список

lis_0 = [1, 2, 3]
lis_x = [lis_0]  * 3
print(lis_x)

# Если изменить элемент в lis_x, то он изменится и в lis_0, поскольку тип изменяемый
# все ссылки остаются активными и исходный объект тоже изменяется:

lis_x[0][0] = 9
print(lis_x)
print(lis_0)

# В списках можно делать срезы. Указываем с какого элемента по какой и с каким шагом
# x[start:end:step]

x = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print(x[2:]) # выводим с третьего по счету элемента (нумерация в питоне с нуля)
print(x[3:8:2]) # выводим с 4го элемента по 8й с шагом 2
print(x[::-1]) # выводим инвертированный список

# Задача: проверить, является ли число палиндромом
b = 1234321 # Заданное число
c = list(str(b)) # Перевели переменную из типа int в string, а затем в list
print(c == c[::-1]) # Проверяем, равен ли исходный список инвертированному

"""Операции над списками"""

y = ['a', 'b', 'c', 'd']
y.append('e')  # добавляет элемент в конец списка
y.extend(['e', 'f', 'g']) # вклеиваем в список что-то другое
print(y)

print(y.pop(1)) # вырезает из списка элемент с заданным индексом и выводит его
print(y)

"""dict - словари - упорядоченная (с Phython 3.6) структура пар ключ-значение"""

di = {}
di = dict()
di = {
    'cat': 'meow',
    'dog': 'woof',
    'cow': 'moo',
    'fox': '????',
}
print('What does the fox say', di['fox'])

print('cat' in di)  # проверка на наличие ключа в словаре

di.update({'bird': 'tweet'})  # добавляет элементы в конец словаря
di.update(duck = 'quack')   #другой способ написания
print(di)

# При изменении нового словаря со ссылкой на старый, изменится и старый, и новый
original = {'a': 1, 'b': 2}
new = original
new.clear()  #  удаляет все элементы из словаря
print(new)
print(original) # оба словаря будут пустыми

# НО! Если создать новый словарь при помощи .copy(), а не прямой ссылки
# то действия над новым словарем не будут отражаться на старом

original_1 = {'a': 1, 'b': 2}
new_1 = original_1.copy()
new_1.clear() 
print(new_1) # пустой
print(original_1) # не изменился

#.get('ключ','что вывести, если не найдется значения по заданному ключу' )
cow_sound = di.get('cow', 'IDK') 
print(cow_sound) # Такой ключ в словаре есть, выведет 'moo'
frog_sound = di.get('frog', 'IDK')
print(frog_sound) # Нет такого ключа в словаре, выведет IDK

dog_sound = di.pop('dog')  # возвращает значение по заданному ключу и удаляет его из словаря
print(dog_sound)
print(di)

duck_sound = di.popitem()  # возвращает и удаляет из словаря последнюю пару "ключ-значение"
print(duck_sound)
print(di)

print(di.setdefault('cat', 'roar')) # если ключ существует в словаре, то возвращает его значение, со словарем ничего не делает
print(di)

print(di.setdefault('tiger', 'roar')) # если такого ключа нет, то добавляет пару в словарь и выводит значение
print(di)

print(di.keys()) # выводит все ключи словаря
print(di.values())  # выводит все значения словаря
print(di.items())  # выводит все пары ключ-значение

"""SET - множества - неупорядоченный набор уникальных элементов, изменяемый тип"""

jojo = set()
jojo = {'a', 'b'}  # нет нумерации, все элементы в единственном экземпляре
jojo.update(['c'])  # добавляет элемент в множество, можно добавить несколько, добавляет itterable объект
jojo.add('c')  # добавляет один элемент в множество
jojo.clear()  # удаляет все элементы из множества

dio = {'a', 'b', 'c', 'd'}
dio.remove('d')  # удаляет элемент из множества по значению
print(dio)
dio.discard('c')  # удаляет элемент из множества, если он там есть
print(dio)
print(dio.pop())  # удаляет случайный элемент из множества и возвращает его

"""Математические операции нам множествами"""

fi = {'a', 'b', 'c', 'd', 'e'}
psi = {'a', 'b'}

print(psi.issubset(fi))  # проверяет, что psi является подмножеством fi
print(fi.issuperset(psi))  # проверяет, что fi является надмножеством psi

print( psi.intersection(fi) )  # возвращает пересечение множеств
print( psi.union(fi) )  # возвращает объединение множеств

print( fi.difference(psi) )  # возвращает разность множеств
print( fi.symmetric_difference(psi) )  # возвращает симметрическую разность (объединение минус пересечение)1

"""Управляющие конструкции"""
# Условия: if
# Циклы: while, for

s = 0
while s<3:
    print(s)
    if s == 1:
        break
    s += 1

# Цикл for проходит по iterable объектам
for i in range(10):  # проходит по числам от 0 до 10, не включая 10
    print(i)

# Можно итерироваться по списку и возвращать просто значения:
for i in ['one', 'two', 'three']:
    print(f'Печатаем элемент {i}') 

# С помощью функции enumerate можно выводить индекс + значение
for ind, val in enumerate(['one', 'two', 'three']):
    print(f'Элемент с номером {ind} и значением {val}')

